SCRIPT  /Users/xavier/.local/state/nvim/view/~=+codebase=+xaviercastro=+src=+layouts=+BlogPost.astro=1.vim
Sourced 1 time
Total time:   0.005922
 Self time:   0.000596

count  total (s)   self (s)
    1              0.000030 let s:so_save = &g:so | let s:siso_save = &g:siso | setg so=0 siso=0 | setl so=-1 siso=-1
    1              0.000002 argglobal
    1              0.000007 setlocal fdm=manual
    1              0.000004 setlocal fde=0
    1              0.000004 setlocal fmr={{{,}}}
    1              0.000004 setlocal fdi=#
    1              0.000005 setlocal fdl=0
    1              0.000004 setlocal fml=1
    1              0.000004 setlocal fdn=20
    1              0.000005 setlocal fen
    1              0.000025 silent! normal! zE
    1              0.000003 36,44fold
    1              0.000011 let &fdl = &fdl
    1              0.000006 let s:l = 1 - ((0 * winheight(0) + 13) / 27)
    1              0.000004 if s:l < 1 | let s:l = 1 | endif
    1              0.000005 keepjumps exe s:l
    1              0.000010 normal! zt
    1              0.000001 keepjumps 1
    1              0.000009 normal! 03|
    1              0.000012 let &g:so = s:so_save | let &g:siso = s:siso_save
    1              0.000004 set hlsearch
    1              0.000001 nohlsearch
    1   0.005742   0.000416 doautoall SessionLoadPost
                            " vim: set ft=vim :

SCRIPT  /Users/xavier/.local/state/nvim/view/~=+codebase=+xaviercastro=+src=+pages=+index.astro=1.vim
Sourced 1 time
Total time:   0.007013
 Self time:   0.000717

count  total (s)   self (s)
    1              0.000030 let s:so_save = &g:so | let s:siso_save = &g:siso | setg so=0 siso=0 | setl so=-1 siso=-1
    1              0.000002 argglobal
    1              0.000007 setlocal fdm=manual
    1              0.000005 setlocal fde=0
    1              0.000004 setlocal fmr={{{,}}}
    1              0.000004 setlocal fdi=#
    1              0.000005 setlocal fdl=0
    1              0.000004 setlocal fml=1
    1              0.000004 setlocal fdn=20
    1              0.000005 setlocal fen
    1              0.000028 silent! normal! zE
    1              0.000011 let &fdl = &fdl
    1              0.000006 let s:l = 31 - ((15 * winheight(0) + 13) / 27)
    1              0.000004 if s:l < 1 | let s:l = 1 | endif
    1              0.000006 keepjumps exe s:l
    1              0.000011 normal! zt
    1              0.000002 keepjumps 31
    1              0.000025 normal! 037|
    1              0.000013 let &g:so = s:so_save | let &g:siso = s:siso_save
    1              0.000003 set hlsearch
    1              0.000001 nohlsearch
    1   0.006779   0.000483 doautoall SessionLoadPost
                            " vim: set ft=vim :

SCRIPT  /Users/xavier/.local/state/nvim/view/~=+codebase=+xaviercastro=+neo-tree buffers [1]=1.vim
Sourced 1 time
Total time:   0.005571
 Self time:   0.000722

count  total (s)   self (s)
    1              0.000039 let s:so_save = &g:so | let s:siso_save = &g:siso | setg so=0 siso=0 | setl so=-1 siso=-1
    1              0.000002 argglobal
    1              0.000009 setlocal fdm=manual
    1              0.000006 setlocal fde=0
    1              0.000006 setlocal fmr={{{,}}}
    1              0.000005 setlocal fdi=#
    1              0.000006 setlocal fdl=0
    1              0.000005 setlocal fml=1
    1              0.000005 setlocal fdn=20
    1              0.000007 setlocal fen
    1              0.000008 let s:l = 8 - ((7 * winheight(0) + 13) / 26)
    1              0.000005 if s:l < 1 | let s:l = 1 | endif
    1              0.000008 keepjumps exe s:l
    1              0.000029 normal! zt
    1              0.000002 keepjumps 8
    1              0.000007 normal! 0
    1              0.000016 let &g:so = s:so_save | let &g:siso = s:siso_save
    1              0.000004 set hlsearch
    1              0.000001 nohlsearch
    1   0.005377   0.000527 doautoall SessionLoadPost
                            " vim: set ft=vim :

FUNCTION  matchup#loader#bufwinenter()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/loader.vim:99
Called 4 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    4              0.000021   if get(b:, 'matchup_delim_enabled', 0)
    4              0.000005     return
                              endif
                              call matchup#loader#init_buffer()

FUNCTION  1()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/matchparen.vim:135
Called 69 times
Total time:   0.005140
 Self time:   0.004830

count  total (s)   self (s)
   69              0.000261   if exists('w:matchup_match_id_list')
                                for l:id in w:matchup_match_id_list
                                  silent! call matchdelete(l:id)
                                endfor
                                unlet! w:matchup_match_id_list
   69              0.000044   endif
   69              0.000148   if exists('s:ns_id')
   69              0.000498     call nvim_buf_clear_namespace(0, s:ns_id, 0, -1)
   69              0.000062   endif
                            
   69              0.000484   if !has('nvim') && exists('t:match_popup') && (exists('*win_gettype') ? win_gettype() !=# 'popup' : &buftype !=# 'terminal')
                                call s:do_popup_autocmd_leave(t:match_popup)
                                call popup_hide(t:match_popup)
   69              0.000177   elseif has('nvim')
   69   0.001181   0.000871     call s:close_floating_win()
   69              0.000042   endif
                            
   69              0.000170   if exists('w:matchup_oldstatus')
                                let &l:statusline = w:matchup_oldstatus
                                unlet w:matchup_oldstatus
                                if exists('#User#MatchupOffscreenLeave')
                                  doautocmd <nomodeline> User MatchupOffscreenLeave
                                endif
   69              0.000036   endif
   69              0.000135   if exists('w:matchup_statusline')
                                unlet w:matchup_statusline
   69              0.000032   endif
                            
   69              0.000136   let w:matchup_need_clear = 0

FUNCTION  2()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/matchparen.vim:203
Called 53 times
Total time:   0.004533
 Self time:   0.000831

count  total (s)   self (s)
                              ""
                              " fade feature: remove highlights after a certain time
                              " {level}
                              "   =  0: prepare for possible loss of cursor support
                              "   =  1: new highlights are coming (cancel prior fade)
                              "   =  2: end of new highlights
                              " {pos}     [lnum, column] of current match
                              " {token}   in/out saves state between calls
                              "
                              " returns 1 if highlighting should be canceled
                            
   53              0.000171   if !g:matchup_matchparen_deferred || !exists('w:matchup_fade_timer')
   53              0.000076     if a:level <= 0
   53   0.003922   0.000221       call s:matchparen.clear()
   53              0.000031     endif
   53              0.000047     return 0
                              endif
                            
                              " jumping between windows
                              if a:level == 0 && win_getid() != get(s:, 'save_win')
                                call timer_pause(w:matchup_fade_timer, 1)
                                if exists('w:matchup_fade_pos')
                                  unlet w:matchup_fade_pos
                                endif
                                call s:matchparen.clear()
                                let s:save_win = win_getid()
                              endif
                            
                              " highlighting might be stale
                              if a:level == 0
                                if exists('w:matchup_fade_pos')
                                  let a:token.save_pos = w:matchup_fade_pos
                                  unlet w:matchup_fade_pos
                                endif
                                if !w:matchup_need_clear
                                  call timer_pause(w:matchup_fade_timer, 1)
                                endif
                                return 0
                              endif
                            
                              " prepare for new highlighting
                              if a:level == 1
                                " if token has no save_pos, cursor was previously off of a match
                                if !has_key(a:token, 'save_pos') || a:pos != a:token.save_pos
                                  " clear immediately
                                  call timer_pause(w:matchup_fade_timer, 1)
                                  call s:matchparen.clear()
                                  return 0
                                endif
                                let w:matchup_fade_pos = a:token.save_pos
                                return 1
                              endif
                            
                              " new highlighting is active
                              if a:level == 2 && a:pos != get(w:, 'matchup_fade_pos', [])
                                " init fade request
                                let w:matchup_fade_pos = a:pos
                                let w:matchup_fade_start = reltime()
                                call timer_pause(w:matchup_fade_timer, 0)
                              endif
                            
                              return 0

FUNCTION  3()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/matchparen.vim:303
Called 79 times
Total time:   0.114745
 Self time:   0.002295

count  total (s)   self (s)
   79              0.000609   if !get(b:, 'matchup_matchparen_deferred', g:matchup_matchparen_deferred)
   79   0.114010   0.001560     return s:matchparen.highlight()
                              endif
                            
                              if !exists('w:matchup_timer')
                                let s:show_delay = g:matchup_matchparen_deferred_show_delay
                                let s:hide_delay = g:matchup_matchparen_deferred_hide_delay
                                let w:matchup_timer = timer_start(s:show_delay, function('s:timer_callback', [ win_getid() ]), {'repeat': -1})
                                if !exists('w:matchup_need_clear')
                                  let w:matchup_need_clear = 0
                                endif
                                let s:fade_time = g:matchup_matchparen_deferred_fade_time
                                if s:fade_time > 0
                                  let w:matchup_fade_timer = timer_start(s:fade_time, function('s:fade_timer_callback', [ win_getid() ]), {'repeat': -1})
                                  call timer_pause(w:matchup_fade_timer, 1)
                                endif
                              endif
                            
                              " keep the timer alive with a heartbeat
                              let w:matchup_pulse_time = reltime()
                            
                              " if the timer is paused, some time has passed
                              if timer_info(w:matchup_timer)[0].paused
                                " unpause the timer
                                call timer_pause(w:matchup_timer, 0)
                            
                                " set the hi time to the pulse time
                                let w:matchup_hi_time = w:matchup_pulse_time
                              endif

FUNCTION  4()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/matchparen.vim:342
Called 89 times
Total time:   0.123329
 Self time:   0.017957

count  total (s)   self (s)
   89              0.000387   if !g:matchup_matchparen_enabled | return | endif
                            
   89              0.000528   if has('vim_starting') | return | endif
                            
   89              0.000324   if !g:matchup_matchparen_pumvisible && pumvisible() | return | endif
                            
                              " try to avoid interfering with some auto-complete plugins
   89              0.000430   if has('*state') && state('a') !=# '' | return | endif
                            
   89              0.000591   if !get(b:, 'matchup_matchparen_enabled', 1) && get(b:, 'matchup_matchparen_fallback', 1) && s:pi_paren_sid()
                                return call(s:pi_paren_fcn, [])
   89              0.000054   endif
                            
   89              0.000349   if !get(b:, 'matchup_matchparen_enabled', 1) | return | endif
                            
   89              0.000403   let l:force_update    = a:0 >= 1 ? a:1 : 0
   89              0.000210   let l:changing_insert = a:0 >= 2 ? a:2 : 0
   89              0.000337   let l:real_mode = l:changing_insert ? v:insertmode : mode()
                            
   89   0.020641   0.006037   if !l:force_update && exists('w:last_changedtick') && exists('w:last_cursor') && matchup#pos#equal(w:last_cursor, matchup#pos#get_cursor()) && w:last_changedtick == b:changedtick
   36              0.000028     return
   53              0.000033   endif
   53              0.000147   let w:last_changedtick = b:changedtick
   53   0.000734   0.000555   let w:last_cursor = matchup#pos#get_cursor()
                            
   53   0.000843   0.000494   call matchup#perf#tic('matchparen.highlight')
                            
                              " request eventual clearing of stale matches
   53              0.000111   let l:token = {}
   53   0.004880   0.000348   call self.fade(0, [], l:token)
                            
   53              0.000131   let l:modes = g:matchup_matchparen_nomode
   53              0.000167   if get(g:, 'matchup_matchparen_novisual', 0)  " deprecated option name
                                let l:modes .= "vV\<c-v>"
   53              0.000025   endif
   53              0.000162   if stridx(l:modes, l:real_mode) >= 0
                                return
   53              0.000024   endif
                            
                              " prevent problems in visual block mode at the end of a line
   53   0.000692   0.000555   if get(matchup#pos#get_cursor(), 4, 0) == 2147483647 && "v\<c-v>" =~? mode()
                                return
   53              0.000025   endif
                            
                              " don't get matches when inside a closed fold
   53              0.000210   if foldclosed(line('.')) > -1
                                return
   53              0.000024   endif
                            
                              " give up when cursor is far into a very long line
   53              0.000243   if &synmaxcol && col('.') > &synmaxcol
                                return
   53              0.000024   endif
                            
                              " in insert mode, cursor is treated as being one behind
   53              0.000167   let l:insertmode = l:real_mode ==# 'i'
                            
                              " start the timeout period
   53              0.000421   let l:timeout = l:insertmode ? get(b:, 'matchup_matchparen_insert_timeout',           g:matchup_matchparen_insert_timeout) : get(b:, 'matchup_matchparen_timeout',           g:matchup_matchparen_timeout)
   53   0.001053   0.000586   call matchup#perf#timeout_start(l:timeout)
                            
   53   0.084465   0.000875   let l:current = matchup#delim#get_current('all', 'both_all', { 'insertmode': l:insertmode,   'stopline': g:matchup_matchparen_stopline,   'highlighting': 1, })
   53   0.001918   0.000405   call matchup#perf#toc('matchparen.highlight', 'get_current')
                            
   53              0.000190   if get(b:, 'matchup_matchparen_deferred', g:matchup_matchparen_deferred)
                                let l:hsa = get(b:, 'matchup_matchparen_hi_surround_always', g:matchup_matchparen_hi_surround_always)
                                if l:hsa > 0 && empty(l:current) || l:hsa > 1
                                  call s:highlight_surrounding(l:insertmode, !empty(l:current))
                                endif
   53              0.000026   endif
                            
   53              0.000088   if empty(l:current)
   53              0.000042     return
                              endif
                            
                              let l:corrlist = matchup#delim#get_matching(l:current, { 'stopline': g:matchup_matchparen_stopline,   'highlighting': 1, })
                              call matchup#perf#toc('matchparen.highlight', 'get_matching')
                              if empty(l:corrlist) | return | endif
                            
                              if g:matchup_transmute_enabled
                                if !exists('w:matchup_matchparen_context')
                                  let w:matchup_matchparen_context = { 'normal': {   'current':   {},   'corrlist':  [],  }, 'prior': {}, 'counter': 0,}
                                endif
                            
                                let w:matchup_matchparen_context.counter += 1
                            
                                if !l:insertmode
                                  let w:matchup_matchparen_context.prior = copy(w:matchup_matchparen_context.normal)
                            
                                  let w:matchup_matchparen_context.normal.current = l:current
                                  let w:matchup_matchparen_context.normal.corrlist = l:corrlist
                                endif
                            
                                " if transmuted, highlight again (will reset timeout)
                                if matchup#transmute#tick(l:insertmode)
                                  " no force_update here because it would screw up prior
                                  return s:matchparen.highlight(0, l:changing_insert)
                                endif
                              endif
                            
                              if !has_key(l:current, 'match_index') || len(l:corrlist) <= (l:current.side ==# 'mid' ? 2 : 1) && !g:matchup_matchparen_singleton
                                " TODO this doesn't catch every case, needs refactor
                                " TODO singleton doesn't work right for mids
                                return
                              endif
                            
                              " prepare for (possibly) new highlights
                              let l:pos = [l:current.lnum, l:current.cnum]
                              if self.fade(1, l:pos, l:token)
                                return
                              endif
                            
                              " store flag meaning highlighting is active
                              let w:matchup_need_clear = 1
                            
                              " disable off-screen when scrolling with j/k
                              let l:scrolling = get(g:matchup_matchparen_offscreen, 'scrolloff', 0) && winheight(0) > 2*&scrolloff && (line('.') == line('w$')-&scrolloff     && line('$') != line('w$')     || line('.') == line('w0')+&scrolloff)
                            
                              " show off-screen matches
                              let l:method = get(g:matchup_matchparen_offscreen, 'method', '')
                              if !empty(l:method) && l:method !=# 'none' && !l:current.skip && !l:scrolling && winheight(0) > 0
                                call s:do_offscreen(l:current, l:method)
                              endif
                            
                              " add highlighting matches
                              call s:add_matches(l:corrlist, l:current)
                            
                              " highlight the background between parentheses
                              if g:matchup_matchparen_hi_background >= 1
                                call s:highlight_background(l:corrlist)
                              endif
                            
                              " new highlights done, request fade away
                              call self.fade(2, l:pos, l:token)
                            
                              call matchup#perf#toc('matchparen.highlight', 'end')

FUNCTION  matchup#delim#set_invert_skip()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/delim.vim:918
Called 53 times
Total time:   0.000136
 Self time:   0.000136

count  total (s)   self (s)
   53              0.000112   let s:invert_skip = a:val

FUNCTION  <SNR>106_IsHighlightSourcesEnabledForBuffer()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-markdown/ftplugin/markdown.vim:859
Called 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
                                " Enable for markdown buffers, and for liquid buffers with markdown format
    1              0.000019     return &filetype =~# 'markdown' || get(b:, 'liquid_subtype', '') =~# 'markdown'

FUNCTION  <SNR>60_init_delim_lists()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/loader.vim:144
Called 1 time
Total time:   0.000359
 Self time:   0.000117

count  total (s)   self (s)
    1              0.000007   let l:lists = { 'delim_tex': {   'regex': [],   'regex_capture': [],   'midmap': {}, },}
                            
                              " very tricky examples:
                              " good: let b:match_words = '\(\(foo\)\(bar\)\):\3\2:end\1'
                              " bad:  let b:match_words = '\(foo\)\(bar\):more\1:and\2:end\1\2'
                            
                              " *subtlety*: there is a huge assumption in matchit:
                              "   ``It should be possible to resolve back references
                              "     from any pattern in the group.''
                              " we don't explicitly check this, but the behavior might
                              " be unpredictable if such groups are encountered.. (ref-1)
                            
    1              0.000004   if exists('g:matchup_hotfix') && has_key(g:matchup_hotfix, &filetype)
                                call call(g:matchup_hotfix[&filetype], [])
    1              0.000004   elseif exists('g:matchup_hotfix_'.&filetype)
                                call call(g:matchup_hotfix_{&filetype}, [])
    1              0.000002   elseif exists('b:matchup_hotfix')
                                call call(b:matchup_hotfix, [])
    1              0.000001   endif
                            
                              " parse matchpairs and b:match_words
    1              0.000005   let l:match_words = !a:no_words ? get(b:, 'match_words', '') : ''
    1              0.000003   if !empty(l:match_words) && l:match_words !~# ':'
                                execute 'let l:match_words =' b:match_words
    1              0.000001   endif
    1              0.000002   let l:simple = empty(l:match_words)
                            
    1              0.000004   let l:mps = escape(&matchpairs, '[$^.*~\\/?]')
    1              0.000004   if !get(b:, 'matchup_delim_nomatchpairs', 0) && !empty(l:mps)
    1              0.000004     let l:match_words .= (l:simple ? '' : ',').l:mps
    1              0.000001   endif
                            
    1              0.000001   if l:simple
    1   0.000302   0.000060     return s:init_delim_lists_fast(l:match_words)
                              endif
                            
                              let l:sets = split(l:match_words, g:matchup#re#not_bslash.',')
                            
                              if a:filter_words
                                call filter(l:sets, 'v:val =~? "^[^a-zA-Z]\\{3,18\\}$"')
                                if empty(l:sets)
                                  return s:init_delim_lists_fast(l:match_words)
                                endif
                              endif
                            
                              " do not duplicate whole groups of match words
                              let l:seen = {}
                              for l:s in l:sets
                                " very special case, escape bare [:]
                                " TODO: the bare [] bug might show up in other places too
                                if l:s ==# '[:]' || l:s ==# '\[:\]'
                                  let l:s = '\[:]'
                                endif
                            
                                if has_key(l:seen, l:s) | continue | endif
                                let l:seen[l:s] = 1
                            
                                if l:s =~# '^\s*$' | continue | endif
                            
                                let l:words = split(l:s, g:matchup#re#not_bslash.':')
                            
                                if len(l:words) < 2 | continue | endif
                            
                                " stores series-level information
                                let l:extra_info = {}
                            
                                " stores information for each word
                                let l:extra_list = map(range(len(l:words)), '{}')
                            
                                " pre-process various \g{special} instructions
                                let l:replacement = { 'hlend': '\%(hlend\)\{0}', 'syn': ''}
                                for l:i in range(len(l:words))
                                  let l:special_flags = []
                                  let l:words[l:i] = substitute(l:words[l:i], g:matchup#re#gspec, '\=[get(l:replacement,submatch(1),""),' . 'add(l:special_flags,' . '[submatch(1),submatch(2)])][0]', 'g')
                                  for [l:f, l:a] in l:special_flags
                                    let l:extra_list[l:i][l:f] = len(l:a) ? l:a : 1
                                  endfor
                                endfor
                            
                                " we will resolve backrefs to produce two sets of words,
                                " one with \(foo\)s and one with \1s, along with a set of
                                " bookkeeping structures
                                let l:words_backref = copy(l:words)
                            
                                " *subtlety*: backref numbers refer to the capture groups
                                " in the 'open' pattern so we have to carefully keep track
                                " of the group renumbering
                                let l:group_renumber = {}
                                let l:augment_comp = {}
                                let l:all_needed_groups = {}
                            
                                " *subtlety*: when replacing things like \1 with \(...\)
                                " the insertion could possibly contain back references of
                                " its own; this poses a very difficult bookkeeping problem,
                                " so we just disallow it.. (ref-2)
                            
                                " get the groups like \(foo\) in the 'open' pattern
                                let l:cg = matchup#loader#get_capture_groups(l:words[0])
                            
                                " if any of these contain \d raise a warning
                                " and substitute it out (ref-2)
                                for l:cg_i in keys(l:cg)
                                  if l:cg[l:cg_i].str =~# g:matchup#re#backref
                                    echohl WarningMsg
                                    echom 'match-up: capture group' l:cg[l:cg_i].str 'should not contain backrefs (ref-2)'
                                    echohl None
                                    let l:cg[l:cg_i].str = substitute(l:cg[l:cg_i].str, g:matchup#re#backref, '', 'g')
                                  endif
                                endfor
                            
                                " for the 'open' pattern, create a series of replacements
                                " of the capture groups with corresponding \9, \8, ..., \1
                                " this must be done deepest to shallowest
                                let l:augments = {}
                                let l:order = matchup#loader#capture_group_replacement_order(l:cg)
                            
                                let l:curaug = l:words[0]
                                " TODO: \0 should match the whole pattern..
                                " augments[0] is the original words[0] with original capture groups
                                let l:augments[0] = l:curaug " XXX does putting this in 0 make sense?
                                for l:j in l:order
                                  " these indexes are not invalid because we work backwards
                                  let l:curaug = strpart(l:curaug, 0, l:cg[l:j].pos[0]) .('\'.l:j).strpart(l:curaug, l:cg[l:j].pos[1])
                                  let l:augments[l:j] = l:curaug
                                endfor
                            
                                " TODO this logic might be bad BADLOGIC
                                " should we not fill groups that aren't needed?
                                " dragons: create the augmentation operators from the
                                " open pattern- this is all super tricky!!
                                " TODO we should be building the augment later, so
                                " we can remove augments that can never be filled
                            
                                " now for the rest of the words...
                                for l:i in range(1, len(l:words)-1)
                            
                                  " first get rid of the capture groups in this pattern
                                  let l:words_backref[l:i] = matchup#loader#remove_capture_groups( l:words_backref[l:i])
                            
                                  " get the necessary \1, \2, etc back-references
                                  let l:needed_groups = []
                                  call substitute(l:words_backref[l:i], g:matchup#re#backref, '\=len(add(l:needed_groups, submatch(1)))', 'g')
                                  call filter(l:needed_groups, 'index(l:needed_groups, v:val) == v:key')
                            
                                  " warn if the back-referenced groups don't actually exist
                                  for l:ng in l:needed_groups
                                    if has_key(l:cg, l:ng)
                                      let l:all_needed_groups[l:ng] = 1
                                    else
                                      echohl WarningMsg
                                      echom 'match-up: backref \' . l:ng 'requested but no ' . 'matching capture group provided'
                                      echohl None
                                    endif
                                  endfor
                            
                                  " substitute capture groups into the backrefs and keep
                                  " track of the mapping to the original backref number
                                  let l:group_renumber[l:i] = {}
                            
                                  let l:cg2 = {}
                                  for l:bref in l:needed_groups
                            
                                    " turn things like \1 into \(...\)
                                    " replacement is guaranteed to exist and not contain \d
                                    let l:words_backref[l:i] = substitute(l:words_backref[l:i], g:matchup#re#backref, '\='''.l:cg[l:bref].str."'", '')    " not global!!
                            
                                    " complicated: need to count the number of inserted groups
                                    let l:prev_max = max(keys(l:cg2))
                                    let l:cg2 = matchup#loader#get_capture_groups(l:words_backref[l:i])
                            
                                    for l:cg2_i in sort(keys(l:cg2), s:Nsort)
                                      if l:cg2_i > l:prev_max
                                        " maps capture groups to 'open' back reference numbers
                                        let l:group_renumber[l:i][l:cg2_i] = l:bref + (l:cg2_i - 1 - l:prev_max)
                                      endif
                                    endfor
                            
                                    " if any backrefs remain, replace with re-numbered versions
                                    let l:words_backref[l:i] = substitute(l:words_backref[l:i], g:matchup#re#not_bslash.'\\'.l:bref, '\\\=l:group_renumber[l:i][submatch(1)]', 'g')
                                  endfor
                            
                                  " mostly a sanity check
                                  if matchup#util#has_duplicate_str(values(l:group_renumber[l:i]))
                                    echohl ErrorMsg
                                    echom 'match-up: duplicate bref in set ' l:s ':' l:i
                                    echohl None
                                  endif
                            
                                  " compile the augment list for this set of backrefs, going
                                  " deepest first and combining as many steps as possible
                                  let l:resolvable = {}
                                  let l:dependency = {}
                            
                                  let l:instruct = []
                                  for l:j in l:order
                                    " the in group is the local number from this word pattern
                                    let l:in_grp_l = keys(filter( deepcopy(l:group_renumber[l:i]), 'v:val == l:j'))
                            
                                    if empty(l:in_grp_l) | continue | endif
                                    let l:in_grp = l:in_grp_l[0]
                            
                                    " if anything depends on this, flush out the current resolvable
                                    if has_key(l:dependency, l:j)
                                      call add(l:instruct, copy(l:resolvable))
                                      let l:dependency = {}
                                    endif
                            
                                    " walk up the tree marking any new dependency
                                    let l:node = l:j
                                    for l:dummy in range(11)
                                      let l:node = l:cg[l:node].parent
                                      if l:node == 0 | break | endif
                                      let l:dependency[l:node] = 1
                                    endfor
                            
                                    " mark l:j as resolvable
                                    let l:resolvable[l:j] = l:in_grp
                                  endfor
                            
                                  if !empty(l:resolvable)
                                    call add(l:instruct, copy(l:resolvable))
                                  endif
                            
                                  " *note*: recall that l:augments[2] is the result of augments
                                  " up to and including 2
                            
                                  " this is a set of instructions of which brefs to resolve
                                  let l:augment_comp[l:i] = []
                                  for l:instr in l:instruct
                                    " the smallest key is the greediest, due to l:order
                                    let l:minkey = min(keys(l:instr))
                                    call insert(l:augment_comp[l:i], { 'inputmap': {}, 'outputmap': {}, 'str': l:augments[l:minkey],})
                            
                                    let l:remaining_out = {}
                                    for l:out_grp in keys(l:cg)
                                      let l:remaining_out[l:out_grp] = 1
                                    endfor
                            
                                    " input map turns this word pattern numbers into 'open' numbers
                                    for [l:out_grp, l:in_grp] in items(l:instr)
                                      let l:augment_comp[l:i][0].inputmap[l:in_grp] = l:out_grp
                                      if has_key(l:remaining_out, l:out_grp)
                                        call remove(l:remaining_out, l:out_grp)
                                      endif
                                    endfor
                            
                                    " output map turns remaining group numbers into 'open' numbers
                                    let l:counter = 1
                                    for l:out_grp in sort(keys(l:remaining_out), s:Nsort)
                                      let l:augment_comp[l:i][0].outputmap[l:counter] = l:out_grp
                                      let l:counter += 1
                                    endfor
                                  endfor
                            
                                  " if l:instruct was empty, there are no constraints
                                  if empty(l:instruct) && !empty(l:augments)
                                    let l:augment_comp[l:i] = [{ 'inputmap': {}, 'outputmap': {}, 'str': l:augments[0],}]
                                    for l:cg_i in keys(l:cg)
                                      let l:augment_comp[l:i][0].outputmap[l:cg_i] = l:cg_i
                                    endfor
                                  endif
                                endfor
                            
                                " strip out unneeded groups in output maps
                                for l:i in keys(l:augment_comp)
                                  for l:aug in l:augment_comp[l:i]
                                    call filter(l:aug.outputmap, 'has_key(l:all_needed_groups, v:key)')
                                  endfor
                                endfor
                            
                                " TODO should l:words[0] actually be used? BADLOGIC
                                " the last element in the order gives the most augmented string
                                " this includes groups that might not actually be needed elsewhere
                                " as a concrete example,
                                " l:augments = { '0': '\<\(wh\%[ile]\|for\)\>', '1': '\<\1\>'}
                                " l:words[0] = \<\1\> (bad)
                                " instead, get the furthest out needed augment.. Heuristic TODO
                                for l:g in add(reverse(copy(l:order)), 0)
                                  if has_key(l:all_needed_groups, l:g)
                                    let l:words[0] = l:augments[l:g]
                                    break
                                  endif
                                endfor
                            
                                " check whether any of these patterns has \zs
                                let l:extra_info.has_zs = match(l:words_backref, g:matchup#re#zs) >= 0
                            
                                " check if hlend is used in any mid
                                if !empty(filter(copy(l:extra_list[1:-2]), 'get(v:val, "hlend")'))
                                  let l:extra_info.mid_hlend = 1
                                endif
                            
                                " this is the original set of words plus the set of augments
                                " TODO this should probably be renamed
                                " (also called regexone)
                                call add(l:lists.delim_tex.regex, { 'open'     : l:words[0], 'close'    : l:words[-1], 'mid'      : join(l:words[1:-2], '\|'), 'mid_list' : l:words[1:-2], 'augments' : l:augments,})
                            
                                " this list has \(groups\) and we also stuff recapture data
                                " TODO this should probably be renamed
                                " (also called regextwo)
                                call add(l:lists.delim_tex.regex_capture, { 'open'     : l:words_backref[0], 'close'    : l:words_backref[-1], 'mid'      : join(l:words_backref[1:-2], '\|'), 'mid_list' : l:words_backref[1:-2], 'need_grp' : l:all_needed_groups, 'grp_renu' : l:group_renumber, 'aug_comp' : l:augment_comp, 'extra_list' : l:extra_list, 'extra_info' : l:extra_info,})
                              endfor
                            
                              " load info for advanced mid-mapper
                              if exists('b:match_midmap') && type(b:match_midmap) == type([])
                                let l:elems = deepcopy(b:match_midmap)
                                let l:lists.delim_tex.midmap = { 'elements': l:elems, 'strike': '\%(' . join(map(range(len(l:elems)),   '"\\(".l:elems[v:val][1]."\\)"'), '\|') . '\)'}
                              endif
                            
                              " generate combined lists
                              let l:lists.delim_all = {}
                              let l:lists.all = {}
                              for l:k in ['regex', 'regex_capture', 'midmap']
                                let l:lists.delim_all[l:k] = l:lists.delim_tex[l:k]
                                let l:lists.all[l:k] = l:lists.delim_all[l:k]
                              endfor
                            
                              return l:lists

FUNCTION  <SNR>31_UpdateBuf()
    Defined: ~/.local/share/nvim/site/pack/packer/start/FastFold/plugin/fastfold.vim:106
Called 35 times
Total time:   0.017345
 Self time:   0.001222

count  total (s)   self (s)
                              " skip if another session still loading
   35              0.000185   if exists('g:SessionLoad') | return | endif
                            
   35              0.000132   let s:curbuf = bufnr('%')
   35   0.008682   0.000300   call s:WinDo("if bufnr('%') is s:curbuf | call s:LeaveWin() | endif")
   35   0.008153   0.000411   call s:WinDo("if bufnr('%') is s:curbuf | call s:EnterWin() | endif")
                            
   35              0.000079   if !a:feedback | return | endif
                            
                              if !exists('w:lastfdm')
                                echomsg "'" . &l:foldmethod . "' folds already continuously updated"
                              else
                                echomsg "updated '" . w:lastfdm . "' folds"
                              endif

FUNCTION  matchup#ts_engine#is_enabled()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/ts_engine.vim:17
Called 1 time
Total time:   0.000057
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000005   if !has('nvim-0.5.0')
                                return 0
    1              0.000001   endif
    1   0.000048   0.000009   return +s:forward('is_enabled', a:bufnr)

FUNCTION  matchup#pos#equal()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/pos.vim:106
Called 79 times
Total time:   0.014258
 Self time:   0.008670

count  total (s)   self (s)
   79   0.004809   0.001666   let l:pos1 = s:parse_args(a:p1)
   79   0.009043   0.006597   let l:pos2 = s:parse_args(a:p2)
   79              0.000330   return l:pos1[:1] == l:pos2[:1]

FUNCTION  <SNR>60_init_delim_lists_fast()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/loader.vim:523
Called 1 time
Total time:   0.000241
 Self time:   0.000241

count  total (s)   self (s)
    1              0.000011   let l:lists = { 'delim_tex': { 'regex': [], 'regex_capture': [] } }
                            
    1              0.000024   let l:sets = split(a:mps, ',')
    1              0.000002   let l:seen = {}
                            
    4              0.000006   for l:s in l:sets
    5              0.000017     if l:s =~# '^\s*$' | continue | endif
                            
    3              0.000006     if l:s ==# '[:]' || l:s ==# '\[:\]'
    1              0.000001       let l:s = '\[:]'
    3              0.000002     endif
                            
    5              0.000009     if has_key(l:seen, l:s) | continue | endif
    3              0.000007     let l:seen[l:s] = 1
                            
    3              0.000013     let l:words = split(l:s, ':')
    5              0.000007     if len(l:words) < 2 | continue | endif
                            
    3              0.000023     call add(l:lists.delim_tex.regex, { 'open'     : l:words[0], 'close'    : l:words[-1], 'mid'      : '', 'mid_list' : [], 'augments' : {},})
    3              0.000038     call add(l:lists.delim_tex.regex_capture, { 'open'     : l:words[0], 'close'    : l:words[-1], 'mid'      : '', 'mid_list' : [], 'need_grp' : {}, 'grp_renu' : {}, 'aug_comp' : {}, 'has_zs'   : 0, 'extra_list' : [{}, {}], 'extra_info' : { 'has_zs': 0, },})
    4              0.000005   endfor
                            
                              " TODO if this is empty!
                            
                              " generate combined lists
    1              0.000002   let l:lists.delim_all = {}
    1              0.000002   let l:lists.all = {}
    3              0.000005   for l:k in ['regex', 'regex_capture']
    2              0.000007     let l:lists.delim_all[l:k] = l:lists.delim_tex[l:k]
    2              0.000005     let l:lists.all[l:k] = l:lists.delim_all[l:k]
    3              0.000002   endfor
                            
    1              0.000001   return l:lists

FUNCTION  <SNR>98_forward()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/ts_engine.vim:10
Called 38 times
Total time:   0.053684
 Self time:   0.053684

count  total (s)   self (s)
   38              0.053518   let l:ret = luaeval( 'require"treesitter-matchup.internal".' . a:fn . '(unpack(_A))', a:000)
   38              0.000114   return l:ret

FUNCTION  matchup#loader#remove_capture_groups()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/loader.vim:707
Called 6 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    6              0.000011   let l:sub_grp = '\(\\\@<!\(\\\\\)*\)\@<=\\('
    6              0.000051   return substitute(a:re, l:sub_grp, '\\%(', 'g')

FUNCTION  <SNR>102_parse_args()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/pos.vim:124
Called 316 times
Total time:   0.009494
 Self time:   0.005588

count  total (s)   self (s)
                              "
                              " The arguments should be in one of the following forms (when unpacked):
                              "
                              "   [lnum, cnum]
                              "   [bufnum, lnum, cnum, ...]
                              "   {'lnum' : lnum, 'cnum' : cnum}
                              "
                            
  316              0.000653   if len(a:args) > 1
  158              0.000531     return s:parse_args([a:args])
  158              0.000288   elseif len(a:args) == 1
  158              0.000602     if type(a:args[0]) == type({})
                                  return [get(a:args[0], 'lnum'), get(a:args[0], 'cnum')]
  158              0.000106     else
  158              0.000314       if len(a:args[0]) == 2
                                    return a:args[0]
  158              0.000083       else
  158              0.000326         return a:args[0][1:]
                                  endif
                                endif
                              else
                                return a:args
                              endif

FUNCTION  <SNR>61_close_floating_win()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/matchparen.vim:899
Called 69 times
Total time:   0.000310
 Self time:   0.000310

count  total (s)   self (s)
   69              0.000172   if !exists('s:float_id')
   69              0.000069     return
                              endif
                              if win_id2win(s:float_id) > 0
                                call s:do_popup_autocmd_leave(s:float_id)
                                call nvim_win_close(s:float_id, 0)
                              endif
                              let s:float_id = 0

FUNCTION  matchup#perf#tic()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/perf.vim:15
Called 143 times
Total time:   0.000836
 Self time:   0.000836

count  total (s)   self (s)
  143              0.000752   let s:time_start[a:context] = reltime()

FUNCTION  <SNR>31_WinDo()
    Defined: ~/.local/share/nvim/site/pack/packer/start/FastFold/plugin/fastfold.vim:73
Called 70 times
Total time:   0.016124
 Self time:   0.015646

count  total (s)   self (s)
                              " avoid errors in CmdWin
   70              0.000320   if exists('*getcmdwintype') && !empty(getcmdwintype())
                                return
   70              0.000039   endif
                              " Work around Vim bug.
                              " See https://groups.google.com/forum/#!topic/vim_dev/LLTw8JV6wKg
   70              0.000248   let curaltwin = winnr('#') ? winnr('#') : 1
   70              0.000119   let currwin=winnr()
   70              0.000471   if &scrollopt =~# '\<jump\>'
   70              0.000277     set scrollopt-=jump
   70              0.000128     let l:restore = 'set scrollopt+=jump'
   70              0.000038   endif
                              " Work around Vim bug.
                              " See https://github.com/vim/vim/issues/4622#issuecomment-508985573
   70              0.000126   let l:currwinwidth = &winwidth
   70              0.000319   let &winwidth = 1
   70   0.007910   0.007432   silent! execute 'keepjumps noautocmd windo ' . a:command
   70              0.001253   silent! execute 'noautocmd ' . curaltwin . 'wincmd w'
   70              0.003462   silent! execute 'noautocmd ' . currwin . 'wincmd w'
   70              0.000242   if exists('l:restore')
   70              0.000385     exe l:restore
   70              0.000041   endif
   70              0.000329   let &winwidth = l:currwinwidth

FUNCTION  matchup#perf#timeout()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/perf.vim:79
Called 53 times
Total time:   0.000169
 Self time:   0.000169

count  total (s)   self (s)
   53              0.000141   return float2nr(s:timeout)

FUNCTION  <SNR>31_Skip()
    Defined: ~/.local/share/nvim/site/pack/packer/start/FastFold/plugin/fastfold.vim:131
Called 9 times
Total time:   0.000115
 Self time:   0.000066

count  total (s)   self (s)
    9   0.000110   0.000061   if s:isSmall()       | return 1 | endif
                              if !s:isReasonable() | return 1 | endif
                              if s:inSkipList()    | return 1 | endif
                              if !empty(&l:buftype)| return 1 | endif
                              if !&l:modifiable    | return 1 | endif
                            
                              return 0

FUNCTION  <SNR>60_init_delim_regexes_generator()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/loader.vim:616
Called 1 time
Total time:   0.000540
 Self time:   0.000474

count  total (s)   self (s)
    1              0.000003   let l:list = b:matchup_delim_lists[a:list_name].regex_capture
                            
                              " build the full regex strings: order matters here
    1              0.000001   let l:regexes = {}
    7              0.000016   for [l:key, l:sidelist] in items(s:sidedict)
    6              0.000009     let l:relist = []
                            
   24              0.000020     for l:set in l:list
   48              0.000042       for l:side in l:sidelist
   30              0.000052         if strlen(l:set[l:side])
   21              0.000049           call add(l:relist, l:set[l:side])
   30              0.000014         endif
   48              0.000022       endfor
   24              0.000011     endfor
                            
    6   0.000161   0.000096     let l:regexes[l:key] = matchup#loader#remove_capture_groups( '\%(' . join(l:relist, '\|') . '\)')
    7              0.000005   endfor
                            
    1              0.000001   return l:regexes

FUNCTION  <SNR>106_MarkdownClearSyntaxVariables()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-markdown/ftplugin/markdown.vim:874
Called 1 time
Total time:   0.000038
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000034   0.000013     if s:IsHighlightSourcesEnabledForBuffer()
                                    unlet! b:mkd_included_filetypes
    1              0.000001     endif

FUNCTION  matchup#ts_engine#is_hl_enabled()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/ts_engine.vim:24
Called 1 time
Total time:   0.000034
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000003   if !has('nvim-0.5.0')
                                return 0
    1              0.000001   endif
    1   0.000028   0.000007   return +s:forward('is_hl_enabled', a:bufnr)

FUNCTION  <SNR>31_LeaveWin()
    Defined: ~/.local/share/nvim/site/pack/packer/start/FastFold/plugin/fastfold.vim:51
Called 9 times
Total time:   0.000223
 Self time:   0.000223

count  total (s)   self (s)
    9              0.000047   if exists('w:predifffdm')
                                if empty(&l:foldmethod) || &l:foldmethod is# 'manual'
                                  let &l:foldmethod = w:predifffdm
                                  unlet w:predifffdm
                                  return
                                elseif &l:foldmethod isnot# 'diff'
                                  unlet w:predifffdm
                                endif
    9              0.000005   endif
                            
    9              0.000021   if exists('w:lastfdm') && &l:foldmethod is# 'diff'
                                let w:predifffdm = w:lastfdm
    9              0.000005   endif
                            
    9              0.000015   if exists('w:lastfdm') && &l:foldmethod is# 'manual'
                                let &l:foldmethod = w:lastfdm
    9              0.000004   endif

FUNCTION  <SNR>103_get_delim()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/delim.vim:325
Called 53 times
Total time:   0.022022
 Self time:   0.015646

count  total (s)   self (s)
                              " arguments: {{{2
                              "   opts = {
                              "     'direction'   : 'next' | 'prev' | 'current'
                              "     'type'        : 'delim_tex'
                              "                   | 'delim_all'
                              "                   | 'all'
                              "     'side'        : 'open'     | 'close'
                              "                   | 'both'     | 'mid'
                              "                   | 'both_all' | 'open_mid'
                              "   }
                              "
                              "  }}}2
                              " returns: {{{2
                              "   delim = {
                              "     lnum     : line number
                              "     cnum     : column number
                              "     type     : e.g., 'delim_tex'
                              "     match    : the actual text match
                              "     side     : 'open' | 'close' | 'mid'
                              "     class    : [ c1, c2 ] identifies the kind of match_words
                              "     skip     : skip state
                              "     get_matching: callback used to get matching delims
                              "     highlighting: whether the request was for highlighting
                              "
                              "     ... Parser dependent ...
                              "     augment  : how to match a corresponding open
                              "     groups   : dict of captured groups
                              "     regexone : the regex items, like \1foo
                              "     regextwo : the regex_capture items, like \(group\)foo
                              "     midmap   : ??
                              "   }
                              "
                              " }}}2
                            
   53              0.000187   if !get(b:, 'matchup_delim_enabled', 0)
                                return {}
   53              0.000032   endif
                            
   53              0.000322   if has('*state') && state('a') !=# '' | return {} | endif
                            
   53   0.000649   0.000365   call matchup#perf#tic('s:get_delim')
                            
   53   0.000758   0.000592   let l:save_pos = matchup#pos#get_cursor()
                            
   53   0.002854   0.000506   call matchup#loader#refresh_match_words()
                            
                              " this contains all the patterns for the specified type and side
   53              0.000241   let l:re = b:matchup_delim_re[a:opts.type][a:opts.side]
                            
   53              0.000142   let l:cursorpos = col('.')
                            
   53              0.000160   let l:insertmode = get(a:opts, 'insertmode', 0)
   53              0.000103   if l:cursorpos > 1 && l:insertmode
   25              0.000054     let l:cursorpos -= 1
   53              0.000029   endif
   53              0.000327   if l:cursorpos > strlen(getline('.')) && stridx("vV\<c-v>", mode()) > -1
                                let l:cursorpos -= 1
   53              0.000035   endif
                            
   53   0.000689   0.000552   call matchup#delim#set_invert_skip(0)
                            
   53              0.000105   if a:opts.direction ==# 'current'
   53              0.000422     let l:check_skip = get(a:opts, 'check_skip', g:matchup_delim_noskips >= 2 || g:matchup_delim_noskips >= 1     && getline(line('.'))[l:cursorpos-1] =~? '[^[:punct:]]')
   53              0.000164     if l:check_skip && matchup#delim#skip(line('.'), l:cursorpos)
                                  return {}
   53              0.000030     endif
                              else
                                " check skip if cursor is not currently in skip
                                let l:check_skip = get(a:opts, 'check_skip', !matchup#delim#skip(line('.'), l:cursorpos) || g:matchup_delim_noskips >= 2)
   53              0.000029   endif
                            
   53              0.000130   let a:opts.cursorpos = l:cursorpos
                            
                              " for current, we want to find matches that end after the cursor
                              " note: we expect this to give false-positives with \ze
   53              0.000085   if a:opts.direction ==# 'current'
   53              0.000262     let l:re .= '\%>'.(l:cursorpos).'c'
   53              0.000033   endif
                            
                              " allow overlapping delimiters
                              " without this, the > in <tag> would not be found
   53              0.000198   if b:matchup_delim_re[a:opts.type]._engine_info.has_zs[a:opts.side]
                                let l:save_cpo = &cpo
                                noautocmd set cpo-=c
   53              0.000037   else
                                " faster than changing cpo but doesn't work right with \zs
   53              0.000103     let l:re .= '\&'
   53              0.000028   endif
                            
   53              0.000102   let l:need_restore_cursor = 0
                            
                              " stopline may depend on the current action
   53              0.000183   let l:stopline = get(a:opts, 'stopline', s:stopline)
                            
                              " in the first pass, we get matching line and column numbers
                              " this is intended to be as fast as possible, with no capture groups
                              " we look for a match on this line (if direction == current)
                              " or forwards or backwards (if direction == next or prev)
                              " for current, we actually search leftwards from the cursor
   53              0.000073   while 1
   53   0.000685   0.000516     let l:to = matchup#perf#timeout()
   53              0.003150     let [l:lnum, l:cnum] = a:opts.direction ==# 'next' ? searchpos(l:re, 'cnW', line('.') + l:stopline, l:to) : a:opts.direction ==# 'prev'   ? searchpos(l:re, 'bcnW',               max([line('.') - l:stopline, 1]), l:to)   : searchpos(l:re, l:insertmode ? 'bnW' : 'bcnW',               line('.'), l:to)
   53              0.000212     if l:lnum == 0 | break | endif
                            
                                " note: the skip here should not be needed
                                " in 'current' mode, but be explicit
                                if a:opts.direction !=# 'current' && (l:check_skip || g:matchup_delim_noskips == 1     && getline(l:lnum)[l:cnum-1] =~? '[^[:punct:]]') && matchup#delim#skip(l:lnum, l:cnum) && (a:opts.direction ==# 'prev' ? (l:lnum > 1 || l:cnum > 1)     : (l:lnum < line('$') || l:cnum < len(getline('$'))))
                            
                                  " invalid match, move cursor and keep looking
                                  call matchup#pos#set_cursor(a:opts.direction ==# 'next' ? matchup#pos#next(l:lnum, l:cnum) : matchup#pos#prev(l:lnum, l:cnum))
                                  let l:need_restore_cursor = 1
                                  continue
                                endif
                            
                                break
   53              0.000114   endwhile
                            
                              " restore cpo if necessary
                              " note: this messes with cursor position
   53              0.000134   if exists('l:save_cpo')
                                noautocmd let &cpo = l:save_cpo
                                let l:need_restore_cursor = 1
   53              0.000031   endif
                            
                              " restore cursor
   53              0.000065   if l:need_restore_cursor
                                call matchup#pos#set_cursor(l:save_pos)
   53              0.000025   endif
                            
   53   0.002412   0.000574   call matchup#perf#toc('s:get_delim', 'first_pass')
                            
                              " nothing found, leave now
   53              0.000068   if l:lnum == 0
   53   0.001823   0.000387     call matchup#perf#toc('s:get_delim', 'nothing_found')
   53              0.000078     return {}
                              endif
                            
                              if matchup#perf#timeout_check()
                                return {}
                              endif
                            
                              let l:skip_state = 0
                              if !l:check_skip && (!&synmaxcol || l:cnum <= &synmaxcol)
                                " XXX: workaround an apparent obscure vim bug where the
                                " reported syntax id is incorrect on the first synID() call
                                call matchup#delim#skip(l:lnum, l:cnum)
                                if matchup#perf#timeout_check()
                                  return {}
                                endif
                            
                                let l:skip_state = matchup#delim#skip(l:lnum, l:cnum)
                              endif
                            
                              " now we get more data about the match in this position
                              " there may be capture groups which need to be stored
                            
                              " result stub, to be filled by the parser when there is a match
                              let l:result = { 'lnum'     : l:lnum, 'cnum'     : l:cnum, 'type'     : '', 'match'    : '', 'side'     : '', 'class'    : [], 'skip'     : l:skip_state,}
                            
                              for l:P in s:engines.classic.parsers[a:opts.type]
                                let l:parser_result = l:P(l:lnum, l:cnum, a:opts)
                                if !empty(l:parser_result)
                                  let l:result = extend(l:parser_result, l:result, 'keep')
                                  break
                                endif
                              endfor
                            
                              call matchup#perf#toc('s:get_delim', 'got_results')
                            
                              return empty(l:result.type) ? {} : l:result

FUNCTION  nvim_treesitter#indent()
    Defined: ~/.local/share/nvim/site/pack/packer/start/nvim-treesitter/autoload/nvim_treesitter.vim:25
Called 1 time
Total time:   0.001430
 Self time:   0.001430

count  total (s)   self (s)
    1              0.001428 	return luaeval(printf('require"nvim-treesitter.indent".get_indent(%d)', v:lnum))

FUNCTION  <SNR>103_get_delim_multi()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/delim.vim:43
Called 53 times
Total time:   0.082318
 Self time:   0.003394

count  total (s)   self (s)
   53              0.000107   let l:best = {}
  142              0.000524   for l:e in get(get(b:, 'matchup_active_engines', {}), a:opts.type, [])
   89   0.080134   0.001210     let l:res = call(s:engines[l:e].get_delim, [a:opts])
   89              0.000185     if empty(l:res)
   89              0.000093       continue
                                endif
                                if a:opts.direction ==# 'current'
                                  return l:res
                                elseif a:opts.direction ==# 'next' && (empty(l:best) || matchup#pos#smaller(l:res, l:best))
                                  let l:best = l:res
                                elseif a:opts.direction ==# 'prev' && (empty(l:best) || matchup#pos#larger(l:res, l:best))
                                  let l:best = l:res
                                endif
   53              0.000091   endfor
   53              0.000068   return l:best

FUNCTION  <SNR>31_isSmall()
    Defined: ~/.local/share/nvim/site/pack/packer/start/FastFold/plugin/fastfold.vim:157
Called 9 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    9              0.000030   if line('$') <= g:fastfold_minlines
    9              0.000011     return 1
                              else
                                return 0
                              endif

FUNCTION  <SNR>10_SynSet()
    Defined: /usr/local/Cellar/neovim/0.8.1/share/nvim/runtime/syntax/synload.vim:26
Called 1 time
Total time:   0.002741
 Self time:   0.002741

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    1              0.000004   syn clear
    1              0.000002   if exists("b:current_syntax")
                                unlet b:current_syntax
    1              0.000001   endif
                            
    1              0.000004   0verbose let s = expand("<amatch>")
    1              0.000002   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    1              0.000001   elseif s == "OFF"
                                let s = ""
    1              0.000001   endif
                            
    1              0.000001   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
    2              0.000007     for name in split(s, '\.')
    1              0.000002       if !empty(name)
    1              0.001353         exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    1              0.001340         exe "runtime! syntax/" . name . ".lua syntax/" . name . "/*.lua"
    1              0.000001       endif
    2              0.000002     endfor
    1              0.000001   endif

FUNCTION  matchup#perf#timeout_start()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/perf.vim:84
Called 53 times
Total time:   0.000467
 Self time:   0.000467

count  total (s)   self (s)
   53              0.000116   let s:timeout = a:timeout
   53              0.000144   let s:timeout_enabled = (a:timeout == 0) ? 0 : 1
   53              0.000156   let s:timeout_pulse_time = reltime()

FUNCTION  <SNR>1_LoadFTPlugin()
    Defined: /usr/local/Cellar/neovim/0.8.1/share/nvim/runtime/ftplugin.vim:14
Called 1 time
Total time:   0.006487
 Self time:   0.006487

count  total (s)   self (s)
    1              0.000010     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
    1              0.000001     endif
                            
    1              0.000007     let s = expand("<amatch>")
    1              0.000002     if s != ""
    1              0.000011       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    1              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    2              0.000009       for name in split(s, '\.')
    1              0.003364         exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
                                    " Load lua ftplugins
    1              0.003050         exe printf('runtime! ftplugin/%s.lua ftplugin/%s_*.lua ftplugin/%s/*.lua', name, name, name)
    2              0.000004       endfor
    1              0.000001     endif

FUNCTION  matchup#loader#refresh_match_words()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/loader.vim:107
Called 53 times
Total time:   0.002348
 Self time:   0.002348

count  total (s)   self (s)
   53              0.000391   if get(b:, 'match_words', ':') !~# ':'
                                call matchup#perf#tic('refresh')
                            
                                " protect the cursor from the match_words function
                                let l:save_pos = matchup#pos#get_cursor()
                                let l:match_words = ''
                                execute 'let l:match_words =' b:match_words
                                if l:save_pos != matchup#pos#get_cursor()
                                  call matchup#pos#set_cursor(l:save_pos)
                                endif
                            
                                call matchup#perf#toc('refresh', 'function')
                            
                                if has_key(s:match_word_cache, l:match_words)
                                  let b:matchup_delim_lists = s:match_word_cache[l:match_words].delim_lists
                                  let b:matchup_delim_re = s:match_word_cache[l:match_words].delim_regexes
                                  call matchup#perf#toc('refresh', 'cache_hit')
                                else
                                  " re-parse match words
                                  let b:matchup_delim_lists = s:init_delim_lists(0, 0)
                                  let b:matchup_delim_re = s:init_delim_regexes()
                                  let s:match_word_cache[l:match_words] = { 'delim_lists'  : b:matchup_delim_lists, 'delim_regexes': b:matchup_delim_re,}
                                  call matchup#perf#toc('refresh', 'parse')
                                endif
   53              0.000029   endif

FUNCTION  <SNR>31_EnterWin()
    Defined: ~/.local/share/nvim/site/pack/packer/start/FastFold/plugin/fastfold.vim:40
Called 9 times
Total time:   0.000255
 Self time:   0.000140

count  total (s)   self (s)
    9   0.000163   0.000049   if s:Skip()
    9              0.000020     if exists('w:lastfdm')
                                  unlet w:lastfdm
    9              0.000006     endif
                              else
                                let w:lastfdm = &l:foldmethod
                                setlocal foldmethod=manual
    9              0.000005   endif

FUNCTION  matchup#loader#init_buffer()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/loader.vim:21
Called 1 time
Total time:   0.001390
 Self time:   0.000154

count  total (s)   self (s)
    1   0.000016   0.000008   call matchup#perf#tic('loader_init_buffer')
                            
    1              0.000003   let l:has_ts = 0
    1              0.000004   let [l:no_words, l:filt_words] = [0, 0]
    1   0.000067   0.000011   if s:ts_may_be_supported && matchup#ts_engine#is_enabled(bufnr('%'))
                                let l:has_ts = 1
                                if matchup#ts_engine#get_option(bufnr('%'), 'include_match_words')
                                  let l:filt_words = 1
                                else
                                  let l:no_words = 1
                                endif
    1              0.000001   endif
                            
    1              0.000002   let l:has_ts_hl = 0
    1   0.000044   0.000010   if s:ts_may_be_supported && matchup#ts_engine#is_hl_enabled(bufnr('%'))
                                let l:has_ts_hl = 1
                            
                                if matchup#ts_engine#get_option( bufnr('%'), 'additional_vim_regex_highlighting')
                                  if empty(&syntax)
                                    set syntax=ON
                                  else
                                    augroup matchup_syntax
                                      au!
                                      autocmd VimEnter * if empty(&syntax) | set syntax=ON | endif
                                    augroup END
                                  endif
                                endif
    1              0.000001   endif
                            
                              " initialize lists of delimiter pairs and regular expressions
                              " this is the data obtained from parsing b:match_words
    1   0.000371   0.000013   let b:matchup_delim_lists = s:init_delim_lists(l:no_words, l:filt_words)
                            
                              " this is the combined set of regular expressions used for matching
                              " its structure is matchup_delim_re[type][open,close,both,mid,both_all]
    1   0.000750   0.000010   let b:matchup_delim_re = s:init_delim_regexes()
                            
                              " process b:match_skip
    1              0.000001   if l:has_ts_hl
                                let b:matchup_delim_skip = "matchup#ts_syntax#skip_expr(s:effline('.'),s:effcol('.'))"
    1              0.000001   else
    1   0.000015   0.000008     let b:matchup_delim_skip = s:init_delim_skip()
    1              0.000001   endif
                            
                              " enable matching engines
    1              0.000002   let b:matchup_active_engines = {}
                            
    1              0.000001   if l:has_ts
                                for l:t in ['all', 'delim_all', 'delim_py']
                                  let b:matchup_active_engines[l:t] = get(b:matchup_active_engines, l:t, []) + ['tree_sitter']
                                endfor
    1              0.000001   endif
                            
    1              0.000002   if !empty(b:matchup_delim_lists.all.regex)
    4              0.000005     for l:t in ['all', 'delim_all', 'delim_tex']
    3              0.000014       let b:matchup_active_engines[l:t] = get(b:matchup_active_engines, l:t, []) + ['classic']
    4              0.000002     endfor
    1              0.000001   endif
                            
                              " enable/disable for this buffer
    1              0.000003   let b:matchup_delim_enabled = !empty(b:matchup_active_engines)
                            
    1   0.000040   0.000007   call matchup#perf#toc('loader_init_buffer', 'done')

FUNCTION  matchup#delim#get_current()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/delim.vim:28
Called 53 times
Total time:   0.083589
 Self time:   0.001272

count  total (s)   self (s)
   53   0.083538   0.001220   return s:get_delim_multi(extend({ 'direction' : 'current', 'type' : a:type, 'side' : a:side,}, get(a:, '1', {})))

FUNCTION  matchup#pos#get_cursor()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/pos.vim:17
Called 238 times
Total time:   0.000829
 Self time:   0.000829

count  total (s)   self (s)
  238              0.000681     return getcurpos()

FUNCTION  <SNR>60_init_delim_regexes()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/loader.vim:577
Called 1 time
Total time:   0.000740
 Self time:   0.000200

count  total (s)   self (s)
    1              0.000002   let l:re = {}
    1              0.000002   let l:re.delim_all = {}
    1              0.000001   let l:re.all = {}
                            
    1   0.000551   0.000011   let l:re.delim_tex = s:init_delim_regexes_generator('delim_tex')
    1              0.000004   let l:re.delim_tex._engine_info = { 'has_zs': {} }
                            
                              " use a flag for b:match_ignorecase
    1              0.000004   let l:ic = get(b:, 'match_ignorecase', 0) ? '\c' : '\C'
                            
                              " if a particular engine is specified, use that for the patterns
                              " (currently only applied to delim_re TODO)
    1              0.000006   let l:eng = string(get(b:, 'matchup_regexpengine', 0))
    1              0.000003   let l:eng = l:eng > 0 ? '\%#='.l:eng : ''
                            
    7              0.000009   for l:k in keys(s:sidedict)
    6              0.000050     let l:re.delim_tex._engine_info.has_zs[l:k] = l:re.delim_tex[l:k] =~# g:matchup#re#zs
                            
    6              0.000011     if l:re.delim_tex[l:k] ==# '\%(\)'
    1              0.000002       let l:re.delim_tex[l:k] = ''
    5              0.000003     else
                                  " since these patterns are used in searchpos(),
                                  " be explicit about regex mode (set magic mode and ignorecase)
    5              0.000019       let l:re.delim_tex[l:k] = l:eng . '\m' . l:ic . l:re.delim_tex[l:k]
    6              0.000003     endif
                            
    6              0.000014     let l:re.delim_all[l:k] = l:re.delim_tex[l:k]
    6              0.000013     let l:re.all[l:k] = l:re.delim_all[l:k]
    7              0.000005   endfor
                            
    1              0.000002   let l:re.delim_all._engine_info = l:re.delim_tex._engine_info
    1              0.000002   let l:re.all._engine_info = l:re.delim_all._engine_info
                            
    1              0.000001   return l:re

FUNCTION  matchup#perf#toc()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/perf.vim:19
Called 196 times
Total time:   0.006236
 Self time:   0.006236

count  total (s)   self (s)
  196              0.001244   let l:elapsed = s:Reltimefloat(reltime(s:time_start[a:context]))
                            
  196              0.000608   let l:key = a:context.'#'.a:state
  196              0.000569   if has_key(g:matchup#perf#times, l:key)
  196              0.000574     if l:elapsed > g:matchup#perf#times[l:key].maximum
                                  let g:matchup#perf#times[l:key].maximum = l:elapsed
  196              0.000128     endif
  196              0.000542     let g:matchup#perf#times[l:key].last = l:elapsed
  196              0.001006     let g:matchup#perf#times[l:key].emavg = s:alpha*l:elapsed + (1-s:alpha)*g:matchup#perf#times[l:key].emavg
                              else
                                let g:matchup#perf#times[l:key] = { 'maximum' : l:elapsed, 'emavg'   : l:elapsed, 'last'    : l:elapsed,}
  196              0.000105   endif

FUNCTION  matchup#ts_engine#get_delim()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/ts_engine.vim:45
Called 36 times
Total time:   0.056902
 Self time:   0.001667

count  total (s)   self (s)
   36   0.000544   0.000349   call matchup#perf#tic('ts_engine.get_delim')
                            
   36   0.054155   0.000532   let l:res = s:forward('get_delim', bufnr('%'), a:opts)
   36              0.000105   if empty(l:res)
   36   0.001950   0.000533     call matchup#perf#toc('ts_engine.get_delim', 'fail')
   36              0.000064     return {}
                              endif
                            
                              let l:res.get_matching = function('matchup#ts_engine#get_matching')
                            
                              call matchup#perf#toc('ts_engine.get_delim', 'done')
                            
                              return l:res

FUNCTION  <SNR>2_LoadIndent()
    Defined: /usr/local/Cellar/neovim/0.8.1/share/nvim/runtime/indent.vim:13
Called 1 time
Total time:   0.001183
 Self time:   0.001183

count  total (s)   self (s)
    1              0.000004     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    1              0.000001     endif
    1              0.000005     let s = expand("<amatch>")
    1              0.000002     if s != ""
    1              0.000002       if exists("b:did_indent")
                            	unlet b:did_indent
    1              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    2              0.000008       for name in split(s, '\.')
    1              0.000580         exe 'runtime! indent/' . name . '.vim'
    1              0.000568         exe 'runtime! indent/' . name . '.lua'
    2              0.000002       endfor
    1              0.000001     endif

FUNCTION  <SNR>33_try()
    Defined: ~/.local/share/nvim/site/pack/packer/start/indent-blankline.nvim/plugin/indent_blankline.vim:7
Called 89 times
Total time:   0.061034
 Self time:   0.061034

count  total (s)   self (s)
   89              0.000121     try
   89              0.060320         execute a:cmd
                                catch /E12/
                                    return
   89              0.000134     endtry

FUNCTION  <SNR>60_init_delim_skip()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-matchup/autoload/matchup/loader.vim:714
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000003   let l:skip = get(b:, 'match_skip', '')
    1              0.000003   if empty(l:skip) | return '' | endif
                            
                              " s:foo becomes (current syntax item) =~ foo
                              " S:foo becomes (current syntax item) !~ foo
                              " r:foo becomes (line before cursor) =~ foo
                              " R:foo becomes (line before cursor) !~ foo
                              let l:cursyn = "synIDattr(synID(s:effline('.'),s:effcol('.'),1),'name')"
                              let l:preline = "strpart(s:geteffline('.'),0,s:effcol('.'))"
                            
                              if l:skip =~# '^[sSrR]:'
                                let l:syn = strpart(l:skip, 2)
                            
                                let l:skip = { 's': l:cursyn."=~?'".l:syn."'", 'S': l:cursyn."!~?'".l:syn."'", 'r': l:preline."=~?'".l:syn."'", 'R': l:preline."!~?'".l:syn."'",}[l:skip[0]]
                              endif
                            
                              for [l:pat, l:str] in [ [ '\<col\ze(', 's:effcol'   ], [ '\<line\ze(', 's:effline' ], [ '\<getline\ze(', 's:geteffline' ],]
                                let l:skip = substitute(l:skip, l:pat, l:str, 'g')
                              endfor
                            
                              return l:skip

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   89   0.123329   0.017957  4()
   79   0.114745   0.002295  3()
   53   0.083589   0.001272  matchup#delim#get_current()
   53   0.082318   0.003394  <SNR>103_get_delim_multi()
   89   0.061034             <SNR>33_try()
   36   0.056902   0.001667  matchup#ts_engine#get_delim()
   38   0.053684             <SNR>98_forward()
   53   0.022022   0.015646  <SNR>103_get_delim()
   35   0.017345   0.001222  <SNR>31_UpdateBuf()
   70   0.016124   0.015646  <SNR>31_WinDo()
   79   0.014258   0.008670  matchup#pos#equal()
  316   0.009494   0.005588  <SNR>102_parse_args()
    1   0.006487             <SNR>1_LoadFTPlugin()
  196   0.006236             matchup#perf#toc()
   69   0.005140   0.004830  1()
   53   0.004533   0.000831  2()
    1   0.002741             <SNR>10_SynSet()
   53   0.002348             matchup#loader#refresh_match_words()
    1   0.001430             nvim_treesitter#indent()
    1   0.001390   0.000154  matchup#loader#init_buffer()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   89              0.061034  <SNR>33_try()
   38              0.053684  <SNR>98_forward()
   89   0.123329   0.017957  4()
   53   0.022022   0.015646  <SNR>103_get_delim()
   70   0.016124   0.015646  <SNR>31_WinDo()
   79   0.014258   0.008670  matchup#pos#equal()
    1              0.006487  <SNR>1_LoadFTPlugin()
  196              0.006236  matchup#perf#toc()
  316   0.009494   0.005588  <SNR>102_parse_args()
   69   0.005140   0.004830  1()
   53   0.082318   0.003394  <SNR>103_get_delim_multi()
    1              0.002741  <SNR>10_SynSet()
   53              0.002348  matchup#loader#refresh_match_words()
   79   0.114745   0.002295  3()
   36   0.056902   0.001667  matchup#ts_engine#get_delim()
    1              0.001430  nvim_treesitter#indent()
   53   0.083589   0.001272  matchup#delim#get_current()
   35   0.017345   0.001222  <SNR>31_UpdateBuf()
    1              0.001183  <SNR>2_LoadIndent()
  143              0.000836  matchup#perf#tic()

